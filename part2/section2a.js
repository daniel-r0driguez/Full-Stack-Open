// Rendering a collection, modules | Section 2.a

/** RECAP
 * console.log()
 * ======================
 * The difference between an experienced JavaScript
 * programmer and a rookie is that the experienced
 * one uses console.log() 10 - 100 times more. 
 * Also be careful to not concatenate things
 * 'the Java way.
 * Instead of writing:
 * console.log('props value is ' + props);
 * 
 * write:
 * console.log('props value is', props);
 * 
 * This causes the output to be a more useful string
 * for debugging.
 * 
 * JavaScript Arrays
 * =================
 * From here on out, we will be using the functional 
 * programming operators of the JavaScript array, 
 * such as find, filter, and map - all of the time.
 * 
 */

// Higher-Order functions Video
// ===================================
console.log('Higher Order Functions [Filter()]\n=====================');
const animals = [
    {name: 'Fluffykins', species: 'rabbit'},
    {name: 'Caro', species: 'dog'},
    {name: 'Hamilton', species: 'dog'},
    {name: 'Harold', species: 'fish'},
    {name: 'Ursula', species: 'cat'},
    {name: 'Jimmy', species: 'fish'}
];

// isDog is a call-back function for the filter() function.
const isDog = (animal) => {
    return animal.species === 'dog';
};

// Here we create a new array, passing the isDog
// call-back function into the filter() function.
const dogs = animals.filter(isDog);

// As a result, we get a collection of dogs.
console.log(dogs);

// Map Video
// ==========================================
console.log('\nMap()\n============================');
// Like filter(), map() is a higher-order function.
// In this case, we pass an anonymous function
// which returns a new string, containing the name and species of the animal.
// The map() function returns a new array containing these new strings for each object in the animals array.
const names = animals.map((animal) => {
    return animal.name + ' is a ' + animal.species;
})

const namesShortened = animals.map((animal) => animal.name);

console.log(namesShortened);

// Reduce Basics
// =======================================
// Reduce() basically is like a custom function that bends to your wishes, essentially creating a list that you and all lords would bow down to.
const orders = [
    {amount: 250},
    {amount: 400},
    {amount: 100},
    {amount: 325}
];

const totalAmount = orders.reduce((sum, order) => {
    console.log('hello', sum, order);
    return sum + order.amount;
}, 0);

console.log(totalAmount);

// Rendering Collections
// Refer to the lecture-app
////////////////////////////////////////////////////

// Key Attribute
/**
 * Even though the application seems to be working,
 * there is a nasty warning in the console.
 * Warning: Each child in a list should have a 
 * unique "key" prop.
 */

// This basically is telling us that each of the 
// elements generated by the map() method must each 
// have a unique key value: an attribute called key.

// This is why the key attribute is added in lecture-app/src/App.js
// React uses the key attributes of objects in an 
// array to determine how to update the view 
// generated by a component when the component is re-rendered. 
/////////////////////////////////////////////////////

// Map
console.log('\nMap() in depth\n=====================');
// Understanding how the array method map works is 
// crucial for the rest of the course.

// map() always creates a new array.

// Take for example this map() method.

const notes = [
    {
        id: 1,
        content: 'HTML is easy',
        important: true
    },
    {
        id: 2,
        content: 'Browser can execute only JavaScript',
        important: false
    },
    {
        id: 3,
        content: 'GET and POST are the most important methods of HTTP protocol',
        important: true
    }
];

const result = notes.map((note) => note.id);

console.log(result); // Will print out [1, 2, 3]

// Now let's see how its working.
// The call-back function we use for each item in the notes array is (note) => node.id.
// This function simply returns the id of the note object.

// Essentially what the map() function does is loop through the entire array, passing each element as a parameter into the call-back function provide to the map() function.
// What the call-back function returns is up to the programmer, but the map() function always returns a new array filled with elements that the programmer wants the call-back function to return for each item in array.

// Here's an example where you can choose what to return based on what the element contains.
const bools = [true, false, true, false];

const nums = bools.map((bool) => {
    if (bool)
    {
        return 'YES';
    }
    return 'NO';
});

console.log(nums);
////////////////////////////////////////////////////
// Anti-pattern: Array Indexes as Keys
// We could have made the error message on our console disappear by using the array indexes as keys.
// The indexes can be retrieved by passing a second parameter to the callback function of the map method:

// notes.map((note, i) => {...})

// When called like this, i is assigned the value of the index of the position in the array where the note resides.

// However, this is not recommended and can create undesired problems even if it seems to be working just fine.
//////////////////////////////////////////////////
// Refactoring Modules

// Refer to the <Note> component in the lecture-app/src/App.js file.
// Note that the key attribute must now be defined for the Note components, and not for the li tags like before.

// A whole React application can be written in a single file. But that is not very practical.
// Common practice is to declare each component in its own file as an ES6-module.

// We've been using modules the whole time. Refer to the first few lines in index.js

// We import two modules, enabling them to be used in that file.
// The module react-dom/client into the variable ReactDOM, and the module that defines the main component of the app is placed into the variable App.

// Now we will move the Note component into its own module.
// In smaller applications, components are usually placed in a directory called components, which is in turn placed within the src directory.
// The convention is to name the file after the component.

// Now that the Note module has been created and exported, it is now available for us in the variable Note.

// The period - . - in the beginning refers to the current directory, so the module's location is a file called Note.js in the components sub-directory of the current directory.
// The filename extension .js can be omitted.
//////////////////////////////////////////////////
// When the Application Breaks
// It is expected that applications just break down. 
// This is even more so the case with dynamically typed languages, such as JavaScript, where the compiler does not check the data type. For instance, function variables or return values. 

// In these situations, your best way out is the console.log() method.

// Quite often the root of the problem is that the props are expected to be of a different type, or called with a different name than they actually are, and destructuring fails as a result.
// The problem often begins to solve itself when destructuring is removed and we see what the props contain.
///////////////////////////////////////////////////
// Web Developer's Oath
// Programming is hard, that is why I will use all the possible means to make it easier
// 1. I will have my browser developer console open all the time
// 2. I progress with small steps
// 3. I will write lots of console.log statements to make sure I understand how the code behaves and to help pinpointing problems
// 4. If my code does not work, I will not write more code. Instead, I start deleting the code until it works or just return to a state when everything still was still working